"""Define the type of an abstract syntax tree node"""
from functools import cached_property, cache, wraps
from typing import Callable, Any

class node:
    def __init__(self, kind, *children, start:int=..., stop:int=...):
        self.kind = kind
        self.children = children
        self.start = start
        self.stop = stop
        #if start is not ...:
        #    print(kind, start, stop)
    def __iter__(self):
        return iter(self.children)
    def __getitem__(self, __key):
        return self.children[__key]
    def __len__(self):
        return len(self.children)
    def __bool__(self):
        return True
    def __hash__(self):
        return hash((self.kind, self.children))
    def __eq__(self, __o):
        if isinstance(__o, node):
            return self.kind == __o.kind and self.children == __o.children
        return False
    def __repr__(self):
        return 'node' + repr((self.kind, *self.children))
    #@cached_property
    #def shallow(self):
    #    return (self.kind, *(a if isinstance(a, str) else hash(a) for a in self.children))
    #@classmethod
    #def unshallow(cls, shallow, hashdict:dict[int,'node']):
    #    kind = shallow[0]
    #    children = (c if isinstance(c, str) else hashdict[c] for c in shallow[1:])
    #    return cls(kind, *children)
    def walk(self, func, term=lambda x:x):
        return func(self.kind, *(c.walk(func, term) if isinstance(c, node) else term(c) for c in self.children))

type lexer = Callable[[int], node|None]

class T:
    choice = 'Choice'
    sequence = 'Sequence'
    zeroorone = 'ZeroOrOne'
    zeroormore = 'ZeroOrMore'
    oneormore = 'OneOrMore'
    lookahead = 'Lookahead'
    notlookahead = 'NotLookahead'
    label = 'Label'
    string = 'String'
    index = 'Index'
    node = 'Node'
    argument = 'Argument'
    definition = 'Definition'
    dot = 'Dot'
    parseexpr = 'ParseExpr'
    primary = 'Primary'
    spacing = 'Spacing'
    comment = 'Comment'
    leftarrow = 'LEFTARROW'
    slash = 'SLASH'
    arg = 'ARG'
    amp = 'AMP'
    bang = 'BANG'
    question = 'QUESTION'
    star = 'STAR'
    plus = 'PLUS'
    OPEN = 'OPEN'
    close = 'CLOSE'
    space = 'SPACE'
    eol = 'EOL'
    eof = 'EOF'
    char = 'Char'
    charclass = 'CharClass'
    entrypoint = 'Entrypoint'
    definition = 'Definition'
    clear = 'Clear'

class CleanParser:
    """Reimplement the parser to have cleaner internals.
    use node() to represent method
    """
    def __init__(self, **labels:node):
        # resolve labels (nodes) into cachable function applications
        self.__caches = [self.trim]
        self.__caches = []
        index = {}

        @cache
        def resolve(kind, *args):
            if kind == T.index:
                # create new label based on index into existing label
                name = args[0].name
                offset = args[1]
                #name, offset = args
                
                newname = f'{name}:{offset}'
                index[newname] = node(labels[name].kind, *labels[name][int(offset):])
                # turn index into plain label
                kind = T.label
                args = (newname,)
            method: Callable[[Any],node|None] = getattr(self, kind)

            @cache
            @wraps(method)
            def call(idx:int) -> node|None:
                if (n:=method(idx, *args)):
                    self.__extent = max(self.__extent, n.stop)
                return n

            # TODO some methods probably perform better without a cache (Dot)
            self.__caches.append(call)
            if kind == T.label:
                call.name = args[0]
            return call

        self.labels = {name:n.walk(resolve) for name, n in labels.items()}
        # apply the new labels generated by indices in previous walk of resolve()
        # all indices will be resolved in a single pass
        self.labels.update({name:n.walk(resolve) for name,n in index.items()})

        self.__extent = 0
        self.__text = ''
        
    def cache_clear(self):
        for c in self.__caches:
            c.cache_clear()

    def __call__(self, text:str, kind=T.entrypoint, trim=True) -> node|None:
        self.__text = text
        self.cache_clear()
        ast = self.labels[kind](0)
        if ast is None:
            lines = text.split('\n')
            lineno = text.count('\n', 0, self.__extent)
            if lineno > 0:
                print(f'{lineno-1:03}:{lines[lineno-1]}')
                pre = text.rfind('\n', 0, self.__extent)
            else:
                pre = 0
            print(f'{lineno:03}:{lines[lineno]}')
            print('^'.rjust(self.__extent-pre + 4, ' '))
            print(f'{lineno+1:03}:{lines[lineno+1]}')
            print(f'ParseError: failed after line={lineno} char={pre}')
        else:
            if trim:
                return self.trim(ast)
        return ast

    def _node(self, ast:node, memo=None):
        if memo is None:
            memo = []
            newkind, body = ast
            self._node(body, memo)
            return node(newkind, *memo)

        match ast.kind:
            case T.argument:
                memo.append(self.trim(ast))
            case T.sequence:
                for a in ast:
                    self._node(a, memo)
    def _label(self, ast:node, memo=None):
        if memo is None:
            memo = []
            self._label(ast[1], memo)
            match len(memo):
                case 0:
                    return self.trim(ast[1])
                case 1:
                    return memo[0]
                case _:
                    return tuple(memo)

        match ast.kind:
            case T.argument:
                memo.append(self.trim(ast))
            case T.sequence:
                for a in ast:
                    self._node(a, memo)

    unescape = {'\\n':'\n', '\\t':'\t', '\\r':'\r', '\\\\':'\\'}
    escape   = {'\n':'\\n', '\t':'\\t', '\r':'\\r', '\\':'\\\\'}
    def esc(self, s):
        for k,v in self.unescape.items():
            s = s.replace(k,v)
        return s
    def trim(self, ast:node):
        """
        The untrimmed ast contains 5 kinds (Node, Argument, Label, Sequence, String) which are specific to the parser.

        The kinds of the trimmed ast are in the set {n[0] for n in walk(ast) if n.kind = 'Node'}
        The arguments of each output node are a flat list of the 

        If unwrap is false, return a node
        If unwrap is true, turn Sequence into list and String into str, resolve arguments and labels
        """
        match ast.kind:
            case T.node:
                # walk the children, excluding labels and nodes and saving arguments
                return self._node(ast)
            case T.argument:
                return self.trim(ast[0])
            case T.string:
                return self.esc(ast[0])
            case T.label:
                return self._label(ast)
            case T.sequence:
                args = map(self.trim, ast)
                # flatten sequence
                args = tuple(v for a in args for v in (a if isinstance(a, tuple) else (a,)))
                # check if empty
                if not args:
                    return ()
                # merge strings
                if all(isinstance(a, str) for a in args):
                    return self.esc(''.join(args))
                return args
            case _:
                raise ValueError


    def Dot(self, idx):
        if idx < len(self.__text):
            return node(T.string, self.__text[idx], start=idx, stop=idx+1)
    def String(self, idx, literal):
        if self.__text.startswith(literal, idx):
            return node(T.string, literal, start=idx, stop=idx+len(literal))
    def CharClass(self, idx, *chars):
        if idx >= len(self.__text):
            return
        for crange in chars:
            if crange[0] <= self.__text[idx] <= crange[-1]:
                return node(T.string, self.__text[idx], start=idx, stop=idx+1)

    def Choice(self, idx, *exprs) -> node|None:
        for expr in exprs:
            if (x:=expr(idx)) is not None:
                return x

    def Sequence(self, idx, *exprs):
        c = []
        for expr in exprs:
            if (x:= expr(idx)) is None:
                return None
            idx = x.stop
            c.append(x)
        return node(T.sequence, *c, start=c[0].start, stop=c[-1].stop)

    def OneOrMore(self, idx, expr):
        c = [expr(idx)]
        if c[0] is None:
            return
        while (x:=expr(c[-1].stop)) is not None:
            c.append(x)
        return node(T.sequence, *c, start=c[0].start, stop=c[-1].stop)

    def ZeroOrMore(self, idx, expr):
        c = []
        while (x:=expr(idx)) is not None:
            c.append(x)
            idx = x.stop
        if c:
            return node(T.sequence, *c, start=c[0].start, stop=c[-1].stop)
        return node(T.sequence, start=idx, stop=idx)

    def ZeroOrOne(self, idx, expr):
        if (x:=expr(idx)) is None:
            return node(T.sequence, start=idx, stop=idx)
        return x

    def Lookahead(self, idx, expr):
        if expr(idx) is not None:
            return node(T.sequence, start=idx, stop=idx)

    def NotLookahead(self, idx, expr):
        if expr(idx) is None:
            return node(T.sequence, start=idx, stop=idx)

    def Node(self, idx, name, expr):
        if (x:=expr(idx)):
            return node(T.node, name, x, start=x.start, stop=x.stop)

    def Argument(self, idx, expr):
        if (x:=expr(idx)):
            return node(T.argument, x, start=x.start, stop=x.stop)

    def Label(self, idx, name):
        if (x:=self.labels[name](idx)):
            return node(T.label, name, x, start=x.start, stop=x.stop)

    def Index(self, idx, name, offset):
        # this should be resolved into calls to self.Label during initialization
        raise NotImplementedError
        return self.Label(idx, f'{name}:{offset}')


#def fixedpoint():
#    pass
#labels = fixedpoint()
#fixedpoint = CleanParser(**labels)


#from parser import labels, T
#import pprint
#def walk(v):
#    match v:
#        case str():
#            return v
#        case int():
#            return str(v)
#        case [t, *args]:
#            return node(t.name, *(walk(a) for a in args))
#    return v.name
#
#labels = {k:walk(v) for k,v in labels.items()}
#pprint.pp(labels)
labels = {
    'Entrypoint': node('Node', 'Entrypoint', node('Sequence', node('Label', 'Spacing'), node('Argument', node('OneOrMore', node('Label', 'Definition'))), node('Label', 'EOF'))),
    'Definition': node('Node', 'Definition', node('Sequence', node('Argument', node('Choice', node('Label', 'Label'), node('Label', 'Node'))), node('Label', 'LEFTARROW'), node('Argument', node('Label', 'ParseExpr')))),
    'ParseExpr': node('Choice', node('Argument', node('Label', 'Choice')), node('Argument', node('Label', 'Sequence')), node('Choice', node('Argument', node('Label', 'Lookahead')), node('Argument', node('Label', 'NotLookahead')), node('Argument', node('Label', 'Argument'))), node('Choice', node('Argument', node('Label', 'ZeroOrOne')), node('Argument', node('Label', 'ZeroOrMore')), node('Argument', node('Label', 'OneOrMore'))), node('Argument', node('Label', 'Primary'))),
    'Choice': node('Node', 'Choice', node('Sequence', node('Argument', node('Index', node('Label', 'ParseExpr'), '1')), node('OneOrMore', node('Sequence', node('Label', 'SLASH'), node('Argument', node('Index', node('Label', 'ParseExpr'), '1')))))),
    'Sequence': node('Node', 'Sequence', node('Sequence', node('Argument', node('Index', node('Label', 'ParseExpr'), '2')), node('OneOrMore', node('Argument', node('Index', node('Label', 'ParseExpr'), '2'))))),
    'Lookahead': node('Node', 'Lookahead', node('Sequence', node('Label', 'AMP'), node('Argument', node('Index', node('Label', 'ParseExpr'), '3')))),
    'NotLookahead': node('Node', 'NotLookahead', node('Sequence', node('Label', 'BANG'), node('Argument', node('Index', node('Label', 'ParseExpr'), '3')))),
    'Argument': node('Node', 'Argument', node('Sequence', node('Label', 'ARG'), node('Argument', node('Index', node('Label', 'ParseExpr'), '3')))),
    'ZeroOrOne': node('Node', 'ZeroOrOne', node('Sequence', node('Argument', node('Index', node('Label', 'ParseExpr'), '4')), node('Label', 'QUESTION'))),
    'ZeroOrMore': node('Node', 'ZeroOrMore', node('Sequence', node('Argument', node('Index', node('Label', 'ParseExpr'), '4')), node('Label', 'STAR'))),
    'OneOrMore': node('Node', 'OneOrMore', node('Sequence', node('Argument', node('Index', node('Label', 'ParseExpr'), '4')), node('Label', 'PLUS'))),
    'Primary': node('Choice', node('Sequence', node('Label', 'OPEN'), node('Argument', node('Label', 'ParseExpr')), node('Label', 'CLOSE')), node('Argument', node('Label', 'Index')), node('Sequence', node('Argument', node('Label', 'Label')), node('NotLookahead', node('Label', 'LEFTARROW'))), node('Argument', node('Label', 'String')), node('Argument', node('Label', 'CharClass')), node('Argument', node('Label', 'Dot'))),
    'Node': node('Node', 'Node', node('Sequence', node('Label', 'ARG'), node('Argument', node('Label', 'Label')))),
    'Index': node('Node', 'Index', node('Sequence', node('Argument', node('Label', 'Label')), node('String', ':'), node('Argument', node('OneOrMore', node('CharClass', '0-9'))), node('Label', 'Spacing'))),
    'Label': node('Node', 'Label', node('Sequence', node('Argument', node('Sequence', node('CharClass', 'a-z', 'A-Z', '_'), node('ZeroOrMore', node('CharClass', 'a-z', 'A-Z', '_', '0-9')))), node('Label', 'Spacing'))),
    'Spacing': node('ZeroOrMore', node('Choice', node('Label', 'SPACE'), node('Label', 'Comment'))),
    'Comment': node('Sequence', node('String', '#'), node('ZeroOrMore', node('Sequence', node('NotLookahead', node('Label', 'EOL')), node('Dot',))), node('Choice', node('Label', 'EOL'), node('Label', 'EOF'))),
    'LEFTARROW': node('Sequence', node('String', '<-'), node('Label', 'Spacing')),
    'SLASH': node('Sequence', node('String', '/'), node('Label', 'Spacing')),
    'ARG': node('Sequence', node('String', '%'), node('Label', 'Spacing')),
    'AMP': node('Sequence', node('String', '&'), node('Label', 'Spacing')),
    'BANG': node('Sequence', node('String', '!'), node('Label', 'Spacing')),
    'QUESTION': node('Sequence', node('String', '?'), node('Label', 'Spacing')),
    'STAR': node('Sequence', node('String', '*'), node('Label', 'Spacing')),
    'PLUS': node('Sequence', node('String', '+'), node('Label', 'Spacing')),
    'OPEN': node('Sequence', node('Argument', node('String', '(')), node('Label', 'Spacing')),
    'CLOSE': node('Sequence', node('String', ')'), node('Label', 'Spacing')),
    'Dot': node('Node', 'Dot', node('Sequence', node('String', '.'), node('Label', 'Spacing'))),
    'SPACE': node('Choice', node('String', ' '), node('String', '\t'), node('Label', 'EOL')),
    'EOL': node('Choice', node('String', '\r\n'), node('String', '\r'), node('String', '\n')),
    'EOF': node('NotLookahead', node('Dot',)),
    'CharClass': node('Node', 'CharClass', node('Sequence', node('String', '['), node('Choice', node('Argument', node('Sequence', node('Label', 'Char'), node('String', '-'), node('Label', 'Char'))), node('Argument', node('Label', 'Char'))), node('ZeroOrMore', node('Sequence', node('NotLookahead', node('String', ']')), node('Choice', node('Argument', node('Sequence', node('Label', 'Char'), node('String', '-'), node('Label', 'Char'))), node('Argument', node('Label', 'Char'))))), node('String', ']'), node('Label', 'Spacing'))),
    'String': node('Node', 'String', node('Sequence', node('Choice', node('Sequence', node('String', '"'), node('Argument', node('ZeroOrMore', node('Sequence', node('NotLookahead', node('String', '"')), node('Label', 'Char')))), node('String', '"')), node('Sequence', node('String', "'"), node('Argument', node('ZeroOrMore', node('Sequence', node('NotLookahead', node('String', "'")), node('Label', 'Char')))), node('String', "'"))), node('Label', 'Spacing'))),
    'Char': node('Argument', node('Choice', node('Sequence', node('String', '\\'), node('CharClass', ']', '[', 'n', 'r', 't', "'", '"', '\\')), node('Sequence', node('String', '\\'), node('CharClass', '0-2'), node('CharClass', '0-7'), node('CharClass', '0-7')), node('Sequence', node('String', '\\'), node('CharClass', '0-7'), node('ZeroOrOne', node('CharClass', '0-7'))), node('Sequence', node('NotLookahead', node('String', '\\')), node('Dot',))))}

fixedpoint = CleanParser(**labels)

with open('fixedpoint.tr', 'r') as f:
    ast = fixedpoint(f.read())
print((ast))
new_labels = {}
for n in ast[0]:
    #print(f'{n.kind}[:{len(n)}]', n[0], n[0])
    #continue
    if n.kind == T.definition:
        match n[0].kind:
            case T.node:
                name = n[0][0][0]
                new_labels[name] = node(T.node, name, n[1])
            case T.label:
                name = n[0][0]
                new_labels[name] = n[1]
            case _:
                print(f'unrecognized kind {n[0].kind}')
print()
print(new_labels.keys())
print()
print()
for k in new_labels:
    if new_labels[k] == labels[k]:
        continue
    print(k, labels[k])
    print(k, new_labels[k])
    print()
print(labels == new_labels)

                    


#from viz import Digraph
#v = Digraph()
#def walk(n:node|str):
#    h=str(hash(n))
#    if isinstance(n, str):
#        v.node(h, label=repr(n))
#        return
#    v.node(h, label=n.kind)
#    for i,a in enumerate(n):
#        walk(a)
#        v.edge(h, str(hash(a)), label=str(i))
#walk(ast)
#v.render(outfile='parse.png', format='png', cleanup=True, view=True) # XXX this creates a massive graph

